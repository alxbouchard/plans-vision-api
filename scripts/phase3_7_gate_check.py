#!/usr/bin/env python3
"""Phase 3.7 Gate Validation Script.

MCAF-COMPLIANT: This script reads payloads ONLY from the Visual Guide (stable_rules_json).
NO hardcoded payloads. The guide must be generated via /analyze first.

Validates GATE 7A and 7B with quantitative metrics:
- rooms_emitted: total rooms extracted
- rooms_with_number: rooms with non-null room_number
- rooms_with_number_ratio: percentage
- rejection_breakdown: reasons for exclusions

Usage:
    # Option A (recommended): Using project ID from database
    python scripts/phase3_7_gate_check.py --project-id <uuid>

    # Option B: Using exported guide JSON file
    python scripts/phase3_7_gate_check.py --guide path/to/stable_rules.json

Requirements:
    - Guide must contain payloads generated by /analyze (token_detector, pairing, exclude)
    - PDF fixtures in tests/fixtures/
"""

import argparse
import asyncio
import json
import sys
from collections import Counter
from dataclasses import dataclass
from pathlib import Path
from typing import Optional
from uuid import UUID, uuid4

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from src.extraction.tokens import PyMuPDFTokenProvider
from src.extraction.token_block_adapter import TokenBlockAdapter, SyntheticTextBlock
from src.extraction.spatial_room_labeler import SpatialRoomLabeler
from src.agents.schemas import RulePayload, RuleKind
from src.models.entities import ExtractionPolicy


# ═══════════════════════════════════════════════════════════════════════════════
# MCAF GUARD: This script must NOT contain hardcoded payloads
# ═══════════════════════════════════════════════════════════════════════════════
def _mcaf_self_check() -> None:
    """Self-check: verify this script doesn't contain hardcoded payloads.

    GATE 7C: grep for hardcoded patterns in this file.
    If found, the script fails before running any validation.

    The check looks for actual payload definitions, not just mentions.
    """
    import re
    script_path = Path(__file__)
    content = script_path.read_text()

    # Look for actual hardcoded payload instantiations (not imports or type hints)
    # Pattern: RulePayload( followed by kind= (direct construction with values)
    hardcoded_pattern = r'RulePayload\(\s*kind\s*='
    matches = re.findall(hardcoded_pattern, content)

    if matches:
        print("MCAF VIOLATION DETECTED!")
        print(f"Found {len(matches)} hardcoded RulePayload instantiations.")
        print("Payloads must come ONLY from Visual Guide (stable_rules_json).")
        sys.exit(1)


@dataclass
class GateResult:
    """Result of a gate validation."""
    fixture_name: str
    rooms_emitted: int
    rooms_with_number: int
    rooms_with_number_ratio: float
    rooms_name_only: int
    rejection_breakdown: dict[str, int]
    max_rooms: int
    min_number_ratio: float
    passed: bool
    failure_reasons: list[str]
    payloads_used: int
    exclude_payloads: int


def load_payloads_from_guide(guide_path: Path) -> list[RulePayload]:
    """Load payloads from a stable_rules JSON file.

    MCAF: Payloads come from the Visual Guide, not hardcoded.
    """
    with open(guide_path) as f:
        guide_data = json.load(f)

    loaded = []
    stable_rules = guide_data.get("stable_rules", [])

    for rule in stable_rules:
        payload_data = rule.get("payload")
        if payload_data:
            try:
                p = RulePayload(**payload_data)
                loaded.append(p)
            except Exception as e:
                print(f"  Warning: Could not parse payload: {e}")

    return loaded


def load_payloads_from_db(project_id: UUID) -> list[RulePayload]:
    """Load payloads from database for a project.

    MCAF: Payloads come from stable_rules_json generated by /analyze.
    The stable_rules_json is stored in the visual_guides table.
    """
    import sqlite3

    db_path = Path("plans_vision.db")
    if not db_path.exists():
        raise FileNotFoundError(f"Database not found: {db_path}")

    conn = sqlite3.connect(str(db_path))
    cursor = conn.cursor()

    # stable_rules_json is in visual_guides table, not projects table
    cursor.execute(
        "SELECT stable_rules_json FROM visual_guides WHERE project_id = ?",
        (str(project_id),)
    )
    row = cursor.fetchone()
    conn.close()

    if not row or not row[0]:
        raise ValueError(f"No stable_rules_json found for project {project_id}. Run /analyze first.")

    guide_data = json.loads(row[0])
    loaded = []

    stable_rules = guide_data.get("stable_rules", [])
    for rule in stable_rules:
        payload_data = rule.get("payload")
        if payload_data:
            try:
                p = RulePayload(**payload_data)
                loaded.append(p)
            except Exception as e:
                print(f"  Warning: Could not parse payload: {e}")

    return loaded


async def run_extraction(
    pdf_path: Path,
    page_number: int,
    rule_payloads: list[RulePayload],
) -> tuple[list, dict[str, int]]:
    """Run extraction pipeline and collect metrics.

    Returns:
        Tuple of (rooms, rejection_breakdown)
    """
    page_id = uuid4()
    rejection_breakdown: Counter = Counter()

    # Step 1: Extract tokens
    provider = PyMuPDFTokenProvider()
    tokens = await provider.get_tokens(
        page_id=page_id,
        pdf_path=pdf_path,
        page_number=page_number,
    )

    if not tokens:
        rejection_breakdown["no_tokens_extracted"] = 1
        return [], dict(rejection_breakdown)

    # Step 2: Create blocks with adapter (uses payloads from guide)
    adapter = TokenBlockAdapter(payloads=rule_payloads)
    blocks = adapter.create_blocks(tokens, page_id)

    # Track metrics from adapter
    if adapter.last_metrics:
        rejection_breakdown["excluded_by_rule"] = adapter.last_metrics.excluded_by_rule
        for reason, count in adapter.last_metrics.excluded_reasons.items():
            rejection_breakdown[f"exclude:{reason[:50]}"] = count

    paired_blocks = [b for b in blocks if b.room_number_token]
    name_only_blocks = [b for b in blocks if not b.room_number_token]

    rejection_breakdown["paired_successfully"] = len(paired_blocks)
    rejection_breakdown["name_only_no_number_nearby"] = len(name_only_blocks)

    # Step 3: Run SpatialRoomLabeler
    labeler = SpatialRoomLabeler(
        policy=ExtractionPolicy.CONSERVATIVE,
        payloads=rule_payloads,
    )

    rooms = labeler.extract_rooms(
        page_id=page_id,
        text_blocks=blocks,
        door_symbols=[],
    )

    # Analyze room results
    for room in rooms:
        if room.room_number:
            rejection_breakdown["emitted_with_number"] += 1
        else:
            rejection_breakdown["emitted_name_only"] += 1

        if room.confidence < 0.5:
            rejection_breakdown["low_confidence"] += 1

    return rooms, dict(rejection_breakdown)


def validate_gate(
    fixture_name: str,
    rooms: list,
    rejection_breakdown: dict[str, int],
    max_rooms: int,
    min_number_ratio: float,
    rule_payloads: list[RulePayload],
) -> GateResult:
    """Validate gate criteria and return result."""

    rooms_emitted = len(rooms)
    rooms_with_number = len([r for r in rooms if r.room_number])
    rooms_name_only = rooms_emitted - rooms_with_number

    if rooms_emitted > 0:
        rooms_with_number_ratio = rooms_with_number / rooms_emitted
    else:
        rooms_with_number_ratio = 0.0

    # Count payload types
    exclude_payloads = len([p for p in rule_payloads if p.kind == RuleKind.EXCLUDE])

    # Check gate conditions
    failure_reasons = []

    if rooms_emitted == 0:
        failure_reasons.append("REGRESSION: rooms_emitted = 0")

    if rooms_emitted > max_rooms:
        failure_reasons.append(f"TOO_MANY: {rooms_emitted} > {max_rooms}")

    if rooms_with_number_ratio < min_number_ratio:
        failure_reasons.append(
            f"LOW_NUMBER_RATIO: {rooms_with_number_ratio:.0%} < {min_number_ratio:.0%}"
        )

    passed = len(failure_reasons) == 0

    return GateResult(
        fixture_name=fixture_name,
        rooms_emitted=rooms_emitted,
        rooms_with_number=rooms_with_number,
        rooms_with_number_ratio=rooms_with_number_ratio,
        rooms_name_only=rooms_name_only,
        rejection_breakdown=rejection_breakdown,
        max_rooms=max_rooms,
        min_number_ratio=min_number_ratio,
        passed=passed,
        failure_reasons=failure_reasons,
        payloads_used=len(rule_payloads),
        exclude_payloads=exclude_payloads,
    )


def print_gate_result(result: GateResult) -> None:
    """Print gate result in readable format."""
    status = "✓ PASS" if result.passed else "✗ FAIL"

    print(f"\n{'='*60}")
    print(f"GATE: {result.fixture_name}")
    print(f"{'='*60}")
    print(f"Status: {status}")
    print()
    print("Payloads (from Visual Guide):")
    print(f"  total_payloads:         {result.payloads_used}")
    print(f"  exclude_payloads:       {result.exclude_payloads}")
    print()
    print("Metrics:")
    print(f"  rooms_emitted:          {result.rooms_emitted}")
    print(f"  rooms_with_number:      {result.rooms_with_number}")
    print(f"  rooms_with_number_ratio: {result.rooms_with_number_ratio:.1%}")
    print(f"  rooms_name_only:        {result.rooms_name_only}")
    print()
    print("Thresholds:")
    print(f"  max_rooms:              {result.max_rooms}")
    print(f"  min_number_ratio:       {result.min_number_ratio:.0%}")
    print()
    print("Rejection Breakdown:")
    for reason, count in sorted(result.rejection_breakdown.items()):
        print(f"  {reason}: {count}")

    if result.failure_reasons:
        print()
        print("Failure Reasons:")
        for reason in result.failure_reasons:
            print(f"  - {reason}")

    print()


def print_json_metrics(results: list[GateResult]) -> None:
    """Print metrics as JSON for programmatic consumption."""
    output = {
        "gates": [
            {
                "fixture": r.fixture_name,
                "passed": r.passed,
                "metrics": {
                    "rooms_emitted": r.rooms_emitted,
                    "rooms_with_number": r.rooms_with_number,
                    "rooms_with_number_ratio": round(r.rooms_with_number_ratio, 3),
                    "rooms_name_only": r.rooms_name_only,
                },
                "payloads": {
                    "total": r.payloads_used,
                    "exclude_count": r.exclude_payloads,
                },
                "thresholds": {
                    "max_rooms": r.max_rooms,
                    "min_number_ratio": r.min_number_ratio,
                },
                "rejection_breakdown": r.rejection_breakdown,
                "failure_reasons": r.failure_reasons,
            }
            for r in results
        ],
        "all_passed": all(r.passed for r in results),
    }
    print("\n" + "="*60)
    print("JSON OUTPUT")
    print("="*60)
    print(json.dumps(output, indent=2))


async def main() -> int:
    """Run gate validations."""
    # MCAF self-check first
    _mcaf_self_check()

    parser = argparse.ArgumentParser(
        description="Phase 3.7 Gate Validation (MCAF-compliant)"
    )
    parser.add_argument(
        "--guide",
        type=Path,
        help="Path to stable_rules.json file from Visual Guide"
    )
    parser.add_argument(
        "--project-id",
        type=str,
        help="Project UUID to load guide from database"
    )
    args = parser.parse_args()

    # Load payloads - MUST come from guide
    if args.guide:
        print(f"Loading payloads from guide file: {args.guide}")
        rule_payloads = load_payloads_from_guide(args.guide)
    elif args.project_id:
        print(f"Loading payloads from database for project: {args.project_id}")
        rule_payloads = load_payloads_from_db(UUID(args.project_id))
    else:
        print("ERROR: Must specify --guide or --project-id")
        print()
        print("Usage:")
        print("  # Option A (recommended): Using project ID from database")
        print("  python scripts/phase3_7_gate_check.py --project-id <uuid>")
        print()
        print("  # Option B: Using exported guide JSON file")
        print("  python scripts/phase3_7_gate_check.py --guide path/to/stable_rules.json")
        print()
        print("First, run /analyze to generate stable_rules_json for a project.")
        return 1

    # Validate we got payloads
    if not rule_payloads:
        print("\nERROR: No payloads found in guide!")
        print("The guide must contain stable_rules with payload objects.")
        print("Run /analyze first to generate the guide.")
        return 1

    # Report payload summary
    exclude_count = len([p for p in rule_payloads if p.kind == RuleKind.EXCLUDE])
    print(f"\nPayloads loaded: {len(rule_payloads)} (exclude: {exclude_count})")

    if exclude_count == 0:
        print("\nWARNING: No exclude payloads found in guide!")
        print("Gates will likely fail. The guide must generate exclude payloads.")

    for p in rule_payloads:
        kind_str = p.kind.value if hasattr(p.kind, 'value') else str(p.kind)
        if p.kind == RuleKind.EXCLUDE:
            pattern_preview = p.pattern[:40] if p.pattern else "none"
            print(f"  - {kind_str}: pattern={pattern_preview}...")
        else:
            print(f"  - {kind_str}: {p.token_type or p.name_token}")

    results = []

    # GATE 7A: Addenda page 1
    addenda_pdf = Path("tests/fixtures/23-333 - EJ - Addenda - A-01 - Plans.pdf")
    if addenda_pdf.exists():
        rooms, breakdown = await run_extraction(addenda_pdf, 0, rule_payloads)
        result = validate_gate(
            fixture_name="GATE_7A_Addenda",
            rooms=rooms,
            rejection_breakdown=breakdown,
            max_rooms=60,
            min_number_ratio=0.70,
            rule_payloads=rule_payloads,
        )
        results.append(result)
        print_gate_result(result)
    else:
        print(f"\nWARNING: {addenda_pdf} not found - skipping GATE 7A")

    # GATE 7B: Plan structure construction page 5 (floor plan page)
    structure_pdf = Path("tests/fixtures/Plan structure construction.pdf")
    if structure_pdf.exists():
        rooms, breakdown = await run_extraction(structure_pdf, 4, rule_payloads)
        result = validate_gate(
            fixture_name="GATE_7B_Structure",
            rooms=rooms,
            rejection_breakdown=breakdown,
            max_rooms=150,
            min_number_ratio=0.50,
            rule_payloads=rule_payloads,
        )
        results.append(result)
        print_gate_result(result)
    else:
        print(f"\nWARNING: {structure_pdf} not found - skipping GATE 7B")

    # Print JSON output
    if results:
        print_json_metrics(results)

    # Summary
    print("\n" + "="*60)
    print("SUMMARY")
    print("="*60)

    all_passed = True
    for result in results:
        status = "PASS" if result.passed else "FAIL"
        print(f"  {result.fixture_name}: {status}")
        if not result.passed:
            all_passed = False

    if not results:
        print("  No fixtures found - cannot validate gates")
        return 1

    if all_passed:
        print("\nAll gates passed!")
        return 0
    else:
        print("\nSome gates failed.")
        if exclude_count == 0:
            print("\nNOTE: No exclude payloads in guide. Fix the guide to generate exclude rules.")
        return 1


if __name__ == "__main__":
    exit_code = asyncio.run(main())
    sys.exit(exit_code)
